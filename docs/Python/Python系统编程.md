# 一、多进程(Process)

## 1. py线程池、进程池
1. PY3标准库: from concurrent import futures
2. **concurrent.futures** 模块,提供**ThreadPoolExecutor (线程池**)和**ProcessPoolExecutor (进程池**)两个类
2. 用于执行并发的后台任务
---
1. fork()函数，fork一个子进程，windows上不支持fork
2. 多进程中，每个进程中所有数据（包括全局变量）都各自拥有⼀份，互不影响(读时共享，写时复制)
3. 跨平台的多进程模块multiprocessing
4. multiprocessing中的Process，多进程
5. Pool进程池

```python
po=Pool(3) #定义⼀个进程池，最⼤进程数3
for i in range(0,10):
    po.apply_async(调用的目标函数,(参数元组,))
# 异步调用
```

6. 进程间通信：
-  队列 **Queue**
-  管道 **Pipe** 队列就是管道加锁实现的
-  进程池 Pool
-  进程池中使用
-  Queue-->**Manager().Queue()**

## 2. 并行和并发？
1. 并行：同一时刻多个任务同时在运行。
2. 并发：在同一时间间隔内多个任务都在运行，但是并不会在同一时刻同时运行，存在交替执行的情
况。**线程是并发，进程是并行**；
1. **多进程适合在 CPU 密集型操作，多线程适合在 IO 密集型操作**

## 3. 进程、线程、协程？
1. **进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元**
2. 进程：**一个运行的程序（代码）就是一个进程**，没有运行的代码叫程序，**进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所以进程间数据不共享，开销大**。
3. 线程： **调度执行的最小单位**，也叫执行路径，**不能独立存在，依赖进程存在，一个进程至少有一个线程，叫主线程**，**而多个线程共享内存(数据共享，共享全局变量)，从而极大地提高了程序的运行效率。**
4. 协程：**是一种用户态的轻量级线程**，**协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。 协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切
换非常快。**

# 二、多线程(Thread)
1. 线程同步保证了数据的正确性
2. 互斥锁保证了数据的正确性
3. 锁的好处：
确保了某段关键代码只能由⼀个线程从头到尾完整地执⾏
1. 锁的坏处：
阻碍了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有
的锁时，可能会造成死锁
5. 避免死锁-->程序设计时要尽量避免（银行家算法）,添加超时时间等
6. 生产者消费者模式，解耦用的

# 三、协程(coroutine)
1. 使用**gevent模块**帮助我们自动切换协程
2. 协程会在函数被暂停运行时保存函数的运行状态，并可以从保存的状态中恢复并继续运行。
3. 很熟悉的味道有没有，这不就是操作系统对线程的调度嘛，线程也可以被暂停，操作系统保存线程运行状态然后去调度其它线程，此后该线程再次被分配CPU时还可以继续运行，就像没有被暂停过一样。
4. **只不过线程的调度是操作系统实现的，这些对程序员都不可见，而协程是在用户态实现的，对程序员可见。**
5. 协程理解为用户态线程
6. 普通线程函数运行时需要的上下文context保存在进程的内存空间里的栈区。
7. **协程的上下文切换数据保存在进程的内存空间里的堆区**
8. 使用协程理论上我们可以开启无数并发执行流，只要堆区空间足够，同时还没有创建线程的开销，所有协程的调度、切换都发生在用户态。
9. 即使你创建了N多协程，但在操作系统看来依然只有一个线程，也就是说协程对操作系统来说是不可见的
10. **协程的本质就是单线程，它不能同时将单个CPU的多核用上，协程需要配合进程才能运行在多核CPU上**
11. 使用python中的**第三方库gevent或eventlet开发协程编程**，使用他**的monkey patch完成io阻塞的自动切换**，确保程序运行，避免io等待。

```python
1. 简单的协程实现
# py3中
import time
def A():
    while True:
        print("----A---")
        yield
        time.sleep(0.5)
def B(c):
    while True:
        print("----B---")
        next(c)
        time.sleep(0.5)
if __name__**'__main__':
    a = A()
    B(a)
# 结果
----B---
----A---
----B---
----A---
----B---
----A---
# 继续
```
# 四、主线程，子线程编程
1. 启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行:

```
 1 def loop(x):
 2     print("%s start" % threading.current_thread().name)
 3     for i in range(x):
 4         time.sleep(1)
 5         print("%s:%d" % (threading.current_thread().name, i))
 6     print("%s stop" % threading.current_thread().name)
 7 
 8 
 9 print("%s start" % threading.current_thread().name)
10 t1 = threading.Thread(target=loop, args=(6,))
# 守护线程，一旦主线程结束，子线程立刻结束
# t1.setDaemon(True)
11 t1.start()
# t1.join() 主线程等待子线程执行完
13 print("%s stop" % threading.current_thread().name
# 结果：主线程MainThread先于子线程Thread-1退出
```
2. 若加入t1.join(),则主线程会等待子线程执行完退出才继续执行
3. **守护线程**：主线程退出的时候，不管子线程运行到哪里，强行让子线程退出，可以使用**setDaemon(True)方法**，在start()之前
4. Lock()锁：加锁，确保只有一个线程正在修改数据

```
lock = threading.Lock()
# 先获取锁
lock.acquire()
执行代码函数操作
# 释放锁
lock.release()
```
5. **GIL锁**，全局解释器锁，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，**多线程在Python中只能交替执行**，即使100个线程跑在100核CPU上，也只能用到1个核。
6. **Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。**
