# 一、概述
1. **RPC**（Remote Procedure Call）：**远程过程调用**，它是一种**通过网络从远程计算机程序上请求服务**，而不需要了解底层网络技术的思想。
2. **RPC跟HTTP不是对立面，RPC中可以使用HTTP作为通讯协议。RPC是一种设计、实现框架，通讯协议只是其中一部分。
RPC的本质是提供了一种轻量无感知的跨进程通信的方式**
3. RPC 是一种技术思想而非一种规范或协议，常见 RPC 技术和框架有:
- **应用级的服务框架**：阿里的 Dubbo/Dubbox、Google gRPC、Spring Boot/Spring Cloud。
- **远程通信协议**：RMI、Socket、SOAP(HTTP XML)、REST(HTTP JSON)。
- **通信框架**：MINA 和 Netty。
4. 一个 RPC 的核心功能主要有 5 个部分组成：客户端、客户端stub、网络
传输模块、服务端stub、服务端。
- 客户端（Client）：服务调用方。
- 客户端存根（Client Stub）：存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。
- 服务端存根（Server Stub）：接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。
- 服务端（Server）：服务的真正提供者。
- Network Service：底层传输，可以是 TCP 或 HTTP。

# 二、实现
1. 要自己实现RPC，要实现3个技术点：
- **服务寻址**
- **数据流的序列化和反序列化**
- **网络传输**
2. 服务寻址可以使用 Call ID 映射。实现方式：**服务注册中心，即服务发现(registory)**。
3. 网络传输：尽管大部分 RPC 框架都使用 TCP 协议，但其实 UDP 也可以，而 gRPC 干脆就用了 HTTP2。
4. **TCP 的连接是最常见的，简要分析基于 TCP 的连接**：通常 TCP 连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。
5. 所以，要实现一个 RPC 框架，只需要把以下三点实现了就基本完成了：
- **Call ID 映射**：可以直接使用函数字符串，也可以使用整数 ID。映射表一般就是一个哈希表。
- **序列化反序列化**：可以自己写，也可以使用 Protobuf 或者 FlatBuffers 之类的。
- **网络传输库**：可以自己写 Socket，或者用 Asio，ZeroMQ，Netty 之类。
6. RPC的网络传输方式可以选择：**TCP协议、UDP协议、HTTP协议、消息队列(如RabbitMQ)**

# 三、RPC与Restful API对比
1. 面向对象不同：
- RPC 更侧重于动作。
- REST 的主体是资源
2. 传输效率：
- **RPC 效率更高**。RPC，使用自定义的 TCP 协议，可以让请求报文体积更小，或者使用 HTTP2 协议，也可以很好的减少报文的体积，提高传输效率。
3. 复杂度：
- RPC 实现复杂，流程繁琐。
- REST 调用及测试都很方便。
4. **RPC 主要用于公司内部的服务调用，性能消耗低，传输效率高，实现复杂。**
5. **HTTP 主要用于对外的异构环境，浏览器接口调用，App 接口调用，第三方接口调用等**。
6. RPC 使用场景（大型的网站，内部子系统较多、接口非常多的情况下适合使用 RPC）：
- 长链接。不必每次通信都要像 HTTP 一样去 3 次握手，减少了网络开销。
- 注册发布机制。RPC 框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。
- 安全性，没有暴露资源操作。
- 微服务支持。就是最近流行的服务化架构、服务化治理，RPC 框架是一个强力的支撑。

# 四、gRPC

## 1. 概述
1. gRPC是google开源的一个RPC框架，面向移动和HTTP2设计。
2. 序列化采用默认的**ProtoBuf**(Google Protocol Buffers)，**使用的是：protobuf3.x**，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与XML，Json类似，但使用二进制，（反）序列化速度快，压缩效率高。
3. **传输协议 采用http2**，性能比http1.1好了很多

## 2. HTTP/2新特性
- **新的二进制格式**
1. HTTP1.X都是基于文本解析，而因为文本表现形式的多样性，基于文本协议的格式解析天然存在健壮性问题。而采用二进制格式后实现方便且健壮
- **多路复用**
1. 多个request共享一个连接。
- **header压缩**
1. 在HTTP1.x中header信息很多，且每次都会重复发送，造成很大浪费。HTTP2.0使用encoder减少了传输的header大小，且通信双方都缓存一份包含了header信息的表，此后的请求可以只发送差异数据，避免信息的重复传输，进一步减少需要传输的内容大小。
- **服务推送**
1. 主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。这个功能帮助客户端将Z放进缓存以备将来之需。也遵守同源策略，且客户端可以拒绝推送过来的资源。
