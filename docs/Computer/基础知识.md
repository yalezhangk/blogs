# 一、内存和缓存区

1. memory是机器的物理内存，有非常快的读写速度。
3. **当内存不够的时候，被踢出的进程被暂时存储到交换区（Swap）。当需要这条被踢出的进程的时候，就从交换区重新加载到内存，否则它不会主动交换到真实内存中。**
4. 计算机对内存分为物理内存与虚拟内存。这里的虚拟内存即所谓的swap，由磁盘代替内存
5. 对于使用多大比例内存之后开始使用swap，在系统的配置文件中可以通过调整参数进行修改。
6. cat  /proc/sys/vm/swappiness 
7. 参数可以从0-100进行设置。0就是最大限度使用内存，尽量不使用swap；100就是积极使用swap

# 二、存储单位
1. 计算机存储单位一般用**bit,Byte,KB,MB,GB,TB,PB,EB,ZB,BB来表示（由小到大）**

## 1. 换算
1. 最小单位：bit（比特）, 存放为二进制数，即0或1,。
2. 基本单位是字节byte（B）,8个二进制位(bit)为一个字节(B)，最常用的单位。 (一个字节占8位)
- 1B = 8bit
- 1KB = 1024B
- 依次往上都是1024

# 三、IOPS、带宽、吞吐量

## 1. IOPS
1. IOPS(Input/Output Per Second)即每秒的输入输出量(或读写次数)，指系统在单位时间内处理的最大IO频度，是衡量磁盘性能的主要指标之一。
2. **IOPS**指单位时间内系统处理I/O的请求数量，一般以**每秒处理的I/O请求数量**，I/O请求通常为读或写数据操作请求。
3. 随机读写频繁的应用，如OLTP,IOPS是关键衡量指标。
4. IOPS * I/O size = Bandwidth。

## 2. 吞吐量
1. 数据**吞吐量**（Throughput）**单位时间内可以成功传输的数据数量。**
2. 大量顺序读写的应用，如VOD，更关注吞吐量。
3. 吞吐量，是单位时间内的最大I/O流量。

## 3. 带宽
1. **带宽**（band width）,又叫频宽，指在**固定时间内可以传输的数据数量，在管道中可以传输数据的能力。**
2. 吞吐量与带宽的单位都是**Mbps**
3. **在Web、E-mail、数据库等小文件频繁读写的环境下，性能主要是由IOPS决定**
4. **在视频、测绘等大文件连续读写的环境下，性能主要由带宽决定**
5. **大文件持续传输型的应用需要的是充分的带宽性能，而小文件随机读写的应用则要求足够的I/O能力。超过1MB的就可以算大文件了**

# 四、异步及非阻塞
**从分布式的角度考虑**

## 1、同步与异步
1. **同步和异步关注的是消息通信机制**。
2. 同步就是发出一个调用时，没得到结果之前，该调用就不返回，即调用者主动等待这个调用的结果。
3. 异步就是调用发出之后，这个调用就直接返回，所以没有返回结果。
4. 即一个异步过程调用发出后，调用者不会立刻得到结果，而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数。
#### 1.1 例子
1. 你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。
## 2、阻塞与非阻塞
1. **阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.**
2. 阻塞调用指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
3. 非阻塞指在得到结果之前，该调用不会阻塞当前线程。
#### 2.2 例子
1. 你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。

# 五、字符编码

## 一、ASCII、Unicode、GBK和UTF-8字符编码的区别联系？
1. **Ascii**: 最初美国人开始使用的字符编码方式，用来保存英文文字的
2. **GB2312**：GB2312是对ASCII的中文扩展。
3. **GBK**：又扩展汉字，形成了GBK标准，GBK包括了GB2312的所有内容，同时又新增了许多汉字（繁体字）
4. **unicode**：ISO （国际标谁化组织）为了解决地区字符编码问题，推出了'unicode'
5. **UTF-8**：为解决unicode如何在网络上传输的问题，推出了UTF标准，utf-8就是每次8个位传输数据，而UTF-16就是每次16个位。
6. **UTF-8就是在互联网上使用最广的一种unicode的实现方式**，这是为传输而设计的编码，**并使编码无国界**，这样就可以显示全世界上所有文化的字符了。

## 二、decode(解码)、encode(编码)
1. 将明文转换为计算机可以识别的的编码文本称为“**编码**”， 反之从计算机可识别的编码文本转回明文为“**解码**”。**python2默认解释器编码->ascii, python3默认解释器编码->utf-8**
- python2 的字符串类型 和编码：
- str 类型 是非Unicode编码（GBK,utf-8,jpg,mp4）
- Unicode 类型字符串是Unicode编码
- python3 的字符串类型和编码：
- str类型字符串是Unicode编码
- bytes 类型字符串是非Unicode编码（GBK,utf-8,jpg,mp4,mp3）

1. **字符串在Python2内部的表示是unicode编码**，因此，在做编码转换时，通常需要以unicode作为中间编码，
2. 即**先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。**
3. **decode的作用是将其他编码的字符串转换成unicode编码**，如str1.decode('gb2312')，表示将gb2312编码的字符串str1转换成unicode编码。
4. **encode的作用是将unicode编码转换成其他编码的字符串**，如str2.encode('gb2312')，表示将unicode编码的字符串str2转换成gb2312编码。
5. 详见Picture/Python/解码编码

# 六、消息队列

## 一、常见的消息队列(MQ)及应用场景？
- 主要的消息队列有：**RabbitMQ、Kafka、ZeroMQ，Redis也可以**
- **异步处理，应用解耦，流量削锋和消息通讯**
- 1 **异步处理**：引入消息队列，将不是必须的、耗时的业务逻辑，异步处理；如发邮件、发送短信
- 2 **应用解耦**：如订单系统将消息写入消息队列，返回用户下单成功，订单系统不再关心其他的后序操作了；而库存系统订阅下单的消息，采用拉/推的方式，获取下单信息，进行库存操作，实现订单系统与库存系统的应用解耦
- 3 **流量削峰**：秒杀，抢团活动中使用；将大量的用户请求写入消息队列，假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面，秒杀业务根据消息队列中的请求信息，再做后续处理
- 4 **消息通讯**：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等

## 二、RabbitMQ VS Kafka
### 1. 应用场景方面
- RabbitMQ：用于**实时的，对可靠性要求较高**的消息传递上。
- kafka：用于处于活跃的**流式数据，大数据量**的数据处理上。
### 2. 架构模型方面
1. producer，broker，consumer
- RabbitMQ：以broker为中心，有消息的确认机制
- kafka：以consumer为中心，无消息的确认机制
### 3. 吞吐量方面
- RabbitMQ：支持消息的可靠的传递，支持事务，不支持批量操作，基于存储的可靠性的要求存储可以采用内存或硬盘，吞吐量小。
- kafka：内部采用消息的批量处理，数据的存储和获取是本地磁盘顺序批量操作，消息处理的效率高，吞吐量高。
### 4. 集群负载均衡方面
- RabbitMQ：本身不支持负载均衡，需要loadbalancer的支持
- kafka：采用zookeeper对集群中的broker，consumer进行管理，可以注册topic到zookeeper上，通过zookeeper的协调机制，producer保存对应的topic的broker信息，可以随机或者轮询发送到broker上，producer可以基于语义指定分片，消息发送到broker的某个分片上。
### 5. 总结
**RabbitMQ**
1. RabbitMQ的消息应当尽可能的小，并且只用来处理实时且要高可靠性的消息。
2. 消费者和生产者的能力尽量对等，否则消息堆积会严重影响RabbitMQ的性能。
3. 集群部署，使用热备，保证消息的可靠性。

**Kafka**
1. 应当有一个非常好的运维监控系统，不单单要监控Kafka本身，还要监控Zookeeper。(kafka强烈的依赖于zookeeper,如果zookeeper挂掉了，那么Kafka也不行了)
2. 对消息顺序不依赖，且不是那么实时的系统。
3.对消息丢失并不那么敏感的系统。
4.从 A 到 B 的流传输，无需复杂的路由，最大吞吐量可达每秒 100k 以上。

# 七、对象存储

## 一、什么是对象存储？
1. pass

## 二、对比文件存储
![image](https://note.youdao.com/yws/res/26861/29CE8F69AF54469894C02C17D7FA12EB)

## 三、基本概念
1. pass

## 四、高级特性
1. 数据灾备
![image](https://note.youdao.com/yws/res/26858/2D3138BF3EA34A368BE3173AFD548E04)

## 五、rgw常用操作
### 1. 创建用户
1. **radosgw-admin user create --uid="testuser" --display-name="TestUser"**
2. 需要保存里面的access_key和secret_key，后面会用到
3. 创建swift用户
swift用户一般是作为子用户创建
4. **radosgw-admin subuser create --uid=testuser --subuser=testuser:swift --access=full**
5. 同样需要保存secret_key
### 2. 测试接口(s3和swift)
####  2.1 s3cmd
1. 一般来说配置Access Key和Secret Key就行了，配置文件保存在/root/.s3cfg
修改/root/.s3cfg,
2. 改为网关地址:
5. host_base = 192.168.69.111:7480
4. host_bucket = 192.168.69.111:7480/%(bucket)
#### 2.2 创建bucket
1. **s3cmd mb s3://bucket_1**
2. Bucket 's3://bucket_1/' created  --> 返回的信息
### 3. 对象操作
####  3.1 上传
1. **s3cmd put cat.txt s3://bucket_1/**
####  3.2 下载
1. **s3cmd get s3://bucket_1/cat.txt --force**
#### 3.3 删除
1. s3cmd del s3://bucket_1/cat.txt
2. delete: 's3://bucket_1/cat.txt  --> 返回的信息
#### 3.4 查看stat
1. radosgw-admin object stat --bucket bucket_1 --object=cat.tx

# 八、快照原理

## 1. 快照定义
1. 快照:关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间点的映像，快照可以是其所表示数据的一个副本，也可以是数据的一个复制品。
2. 快照是完全可用的拷贝，但不是一份完整的拷贝。

## 2. 快照使用场景
- 存储快照，是一种数据保护措施，可以对源数据进行一定程度的保护，**进行回滚恢复，即后悔药。**
- 数据打一份快照，是一份**完全可用的副本**，供其他上层业务当做源数据使用

## 3. 两种快照的实现原理

### 1. 写时复制COW
1. COW(copy on write),写时拷贝
2. 快照创建以后，**若源卷的数据发生变化，会先将原始数据拷贝到快照上，再对源卷进行改写**。
3. 即上层业务每下发一个数据块，存储上，**发生了两次写操作:一次是源卷将数据写入快照卷，一次是上层业务将数据写入源卷**。
4. 采用COW技术的快照，其**源卷即保存着完整的实时数据**，因此，删除快照时，直接销毁了快照卷和映射表，与源卷不存在数据交互。

### 2. 写时重定向ROW
1. ROW(redirect on write),写时重定向
2. 创建快照以后，快照系统把**对数据卷的写请求重定向给了快照**预留的存储空间，**直接将新的数据写入快照卷**。上层业务读源卷时，创建快照前的数据从源卷读，创建快照后产生的数据，从快照卷读

### 3. 对比
1. **COW的快照卷存放的是原始数据，而ROW的快照卷存放的是新数据。**
1. **COW写时有两次写入IO，故适用于读密集型系统，快照删除瞬间完成**
2. **ROW删除快照时需要将数据回拷到源卷，比较耗时，适用于写密集型系统**

# 久、进制转换
1. 不断取余，直到商为0，倒序输出。
2. ![image](https://note.youdao.com/yws/res/26860/D19A27AF104C4E81A6DA5DA2CE4D3709)

# 十、分页及分段
1. 操作系统将内存分为**逻辑地址**和**物理地址**的分配管理方案。
2. 程序的逻辑地址划分为固定大小的页(Page)
3. 物理地址划分为固定大小的帧(Frame)
4. **分页: 操作系统为了方便的管理内存，有效利用内存碎片，而产生了分页机制。**
5. 通过**页表**来对应逻辑地址和物理地址。
6. **分段机制：是为了满足代码的一些逻辑需求。段是出于用户角度考虑的。**
- 如数据共享、数据保护、动态链接等。
- 通过**段表**实现逻辑地址和物理地址的映射关系。
- 每个段内部是连续内存分配，段和段之间时离散分配的。
7. 页大小固定的，由操作系统决定；段大小不确定，由用户程序决定。
