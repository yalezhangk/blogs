# Mysql高级

# 一、数据库索引

## 1. 为什么使用索引
1. 本质:**缩小表中需要查询的数目，避免全表扫描，加快查询速度。**
2. 索引是在表的某一列或某几列上创建的，索引包含一个表中列的值，并且这些值存储在一个数据结构中，索引是一种数据结构(最常见的是B-Tree)
3. **索引中除了保存索引列的值，还存储着一个指向所在行数据的指针，**快速定位数据****。

## 2. 索引原理
1. 索引就像书的目录，通过目录快速准确的定位到想要获取的数据。
2. 实现索引的数据结构有**平衡树(b-tree或b+tree)及哈希表等**，索引分为**聚集索引和非聚集索引**
3. 一个没加主键的表，其数据是无序的放置在磁盘存储器上的，一行一行的整齐排列；**加了主键后，整齐排列就变成了树状结构，也就是‘平衡树’结构，整个表就变成了一个索引。也就是聚集索引**。
4. 这就是为什么**一个表只能有一个主键，一个表只能有一个「聚集索引」**，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。
5. **非聚集索引，树结构中节点的值保存的是表中索引字段的值**，如果给表中多个字段加上索引，就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。
6. 每次给非聚集式索引字段建一个新索引，字段中的数据就会被复制一份出来，用于生成索引。因此，给表添加索引，会增加表的体积， 占用磁盘存储空间。
7. **非聚集索引和聚集索引的区别在于，通过聚集索引可以查到需要查找的数据，而通过非聚集索引可以查到记录对应的主键值，再使用主键的值通过聚集索引查找到需要的数据**
8. 不管以任何方式查询表，最终都会利用主键通过聚集索引来定位到数据，聚集索引（主键）是通往真实数据所在的唯一路径。
9. **覆盖索引**，也是复合索引，为索引指定两个或多个字段，其字段值都会被同步至索引中。这种例外可以不使用聚集索引就能查询出所需要的数据。

## 3. 索引的分类
常见的索引类型有:**主键索引、唯一索引、普通索引、全文索引、组合索引**。

### 3.1 主键索引
1. 即主索引，根据主键建立索引，不允许重复，不允许空值。

```mysql
ALTER TABLE 'table_name' ADD PRIMARY KEY pk_index('col');
```

### 3.2 唯一索引
1. 用来建立索引的列的值必须是唯一的，允许空值

```mysql
ALTER TABLE 'table_name' ADD UNIQUE index_name('col');
```

### 3.3 普通索引
1. 用表中的普通列构建的索引，没有任何限制。

```mysql
ALTER TABLE 'table_name' ADD INDEX index_name('col');
```

### 3.4 全文索引
1. 用大文本对象的列构建的索引

```mysql
ALTER TABLE 'table_name' ADD FULLTEXT INDEX ft_index('col');
```

### 3.5 组合索引
1. 用**多个列组合构建**的索引，这**多个列中的值不允许有空值**

```mysql
ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')；
```

2. 遵循**最左前缀原则，把最常用作检索或排序的列放在最左，依次递减**，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。
3. *在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引

```mysql
# 表示使用col1的前4个字符和col2的前3个字符作为索引
ALTER TABLE 'table_name' ADD INDEX index_name(col1(4),col2（3))；
```

## 4 索引的实现原理
1. **explain + 查询语句**: **用于模拟优化器执行SQL查询语句，分析查询语句或是表结构的性能瓶颈，包括表执行顺序，索引是否使用，表之间的引用等**

```mysql
//explain 加查询语句
explain SELECT * FROM table_name WHERE column_1='123';
```

MySql支持多种存储引擎，各种存储引擎对索引的支持也各不相同。

### 1. 哈希索引
1. 只有memory(内存)存储引擎支持哈希索引，基于索引列的值计算出hashcode，用散列算法，因此访问速度非常快，
2. **只支持精确查找('='、'in')，不支持范围查找和排序**

### 2. 全文索引
1. 全文(fulltext)索引，仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。
2. 全文索引的查询也有自己特殊的语法，而不能使用LIKE %查询字符串%的模糊查询语法

```mysql
SELECT * FROM table_name MATCH(ft_index) AGAINST('查询字符串');
```

3. 对于较大的数据集，把数据添加到一个没有FULLTEXT索引的表，然后添加FULLTEXT索引的速度比把数据添加到一个已经有FULLTEXT索引的表快。

### 3. BTree索引和B+Tree索引

#### 3.1 BTree索引
1. **BTree是平衡搜索多叉树，用二分法查找效率高效**。满足条件如下：
- 每个叶子结点的高度一样，等于h；
- 每个非叶子结点由n-1个key和n个指针point组成，其中d<=n<=2d,key和point相互间隔，结点两端一定是key；
- 叶子结点指针都为null；
- **非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的数据**

#### 3.2 B+Tree索引
1. B+Tree是BTree的一个变种，条件如下:
- B+Tree中的非叶子结点不存储数据，只存储键值；
- **B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址；**
- B+Tree的每个非叶子节点由n个键值key和n个指针point组成
![image](https://note.youdao.com/yws/res/27489/34F0A7611A434E508BAE8319CDC1FE18)

#### 3.3 B+Tree对比BTree的优点
> 1、**B+树的层级更少**：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；
> 
> 2、**B+树查询速度更稳定**：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
> 
> 3、**B+树天然具备排序功能**：B+树所有的**叶子节点数据构成了一个有序链表**，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
> 
> 4、**B+树全节点遍历更快**：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。
> 
> 5、B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。
> 

**BTree非叶子节点存储索引建及data数据，B+Tree叶子节点存储data数据**

1、**磁盘读写代价更低**:
2. 利用磁盘的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找，已知内存的读取速度是外存读取I/O速度的几百倍。
3. 那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，**因为B+Tree的非叶节点中不存储data，就可以存储更多的key**。
2、**查询速度更稳定**:
1. **由于B+Tree非叶子节点不存储数据（data），因此所有的数据都要查询至叶子节点，而叶子节点的高度都是相同的，因此所有数据的查询速度都是一样的**。

### 4. 聚集索引和非聚集索引

#### 4.1 MyISAM——非聚集索引
1. 非聚集索引的**数据表和索引表是分开存储**的
2. **MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址**
#### 4.2 InnoDB——聚集索引
1. 聚簇索引的数据和主键索引存储在一起。
2. **InnoDB中，表数据文件本身是一颗B+Tree数据结构，叶节点包含了完整的数据记录，是聚集式索引，由于InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键，辅助索引依赖于主键索引**

### 5. Spatial (R-Tree)（空间）索引
1. 只有MyISAM支持

## 5 索引未生效的场景
- **使用了like，且以通配符开头('%abc...')**
- **加了联合索引，如果where条件中是OR关系，索引不起作用**
- **联合索引，但是使用时没有符合最左原则（联合索引采用最左原则）**
- **不要在索引列上做任何操作（计算、函数、(自动or手动)类型转换）**
- **当字段类型为字符串时，条件中数据没有使用引号引用。**
SELECT * FROM `tbl_shopmall_product_template` WHERE  productName = 1        扫全表
- **B-tree 索引 is null:即判空索引会失效**
- mysql 在使用不等于(!= 或者<>)的时候有时候无法使用索引会导致全表扫描
- 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)
- 如果mysql估计使用全表扫描要比使用索引快,则不使用索引

# 二、存储引擎

## 1. 介绍
1. 查看当前数据库支持的存储引擎

```mysql
show engines;
```

## 1 主要是**MyISAM** 与 **InnoDB**
- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：**MyISAM 只支持表级锁，而 InnoDB 还支持行级锁，支持更高的并发**。
- 外键：InnoDB 支持外键。
- 索引: InnoDB是聚集索引，数据和索引存放在一块，都位于B+数的叶子节点上；MyISAM是非聚集索引，数据文件和索引文件分开存储。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。
1. MyISAM 以前是默认引擎，5.5版本之后InnoDB为默认的存储引擎
2. InnoDB 支持事务、外键，MyISAM 不支持。
4. **MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到安全性较高的应用**
5. InnoDB 中不保存表的行数， MyISAM 使用count()方法即可
6. 清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM 则会重建表；

## 2 MyISAM
1. **MyISAM适合快速读取操作，主要用于高负载的select，非常适合深受Web开发，支持表级别锁定**，使用一种表格锁定的机制来优化多个并发的读写操作。
2. 三种不同的存储结构：静态型、动态型、压缩型。

## 3 InnoDB
1. **InnoDB 适合频繁修改以及涉及到安全性较高的应用**
1. **支持事务、外键。**
2. **支持行级别锁定**
3. **支持自增长列**

# 三、SQL注入

## 1 原理
1. 当应用程序使用输入内容来构造动态sql语句以访问数据库时，会发生sql注入攻击
2. 把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令

## 2 防止sql注入
1. 永远**不要相信用户的输入，进行校验**，可以通过正则或长度限制，对单引号和双"-"进行转换等。
2. **不要使用动态拼接sql**,可以使用参数化的sql或者直接使用存储过程进行数据查询存取
3. **不要使用管理员权限连接数据库**，尽可能分配单库单管
4. **机密信息加密存放**
5. **使用辅助软件或网站平台来检测sql注入**
6. **检测工具jsky，竭思；网站，亿思网**
7. **sql语句参数化,全部使⽤%s占位**

```mysql
# sql注入， #号是注释，#后面的代码不会执行
username = ''or 1=1#
select * from users where username='' or 1=1#' and password=md5('')
# 等价于, 这样的话，sql语句总会执行
select * from users where username='' or 1=1
sql语句参数化,全部使⽤%s占位
sname = input("请输⼊学⽣姓名：")
# 构造参数列表
params = [sname]
'insert into students(name) values(%s)', params
```

# 四、存储过程

## 1 简介
1. **sql语句执行的时候需要先编译，然后执行**。
2. **存储过程是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过调用存储过程的名字及参数来调用执行它**
3. **是一个可编程的函数，在数据库中创建并保存**。**由一些SQL语句和流程控制语句组成**。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。可以看做是对编程中面向对象方法的模拟，它允许控制数据的访问方式

## 2 优点
- 增强了SQL语言的功能和灵活性，使用流程控制语句编写，可以完成复杂的判断和较复杂的运算
- 被创建后，可以多次重复使用，可随时修改
- 执行速度快。因为他是预编译的，首次调用时，优化器对其进行分析优化，被存储在系统表中；而批量处理的SQL语句每次运行时都需要编译、优化，速度慢
- 减少网络流量，网络中传送的只是该调用语句
- 可以被作为一种安全机制来充分利用，数据库管理员写一个存储过程进行权限赋权，只对相应数据库访问权限限制

## 3 实现
1. 格式：CREATE PROCEDURE 过程名 ([过程参数[,...]])
[特性 ...] 过程体


``` mysql
mysql> DELIMITER //  
mysql> CREATE PROCEDURE proc1(OUT s int)  
    -> BEGIN 
    -> SELECT COUNT(*) INTO s FROM user;  
    -> END 
    -> //  
mysql> DELIMITER ;
```

3. DELIMITER //和DELIMITER ;是声明分隔符，还原分隔符；如果是用MySQL的Administrator管理工具时，可以直接创建，不再需要声明
4. 参数有输入(IN)、输出(OUT)、输入输出(INOUT)参数,开始和结束用BEGIN和END说明
5. IN，调用存储过程时必须指定该参数的值，修改无效
6. OUT,在存储过程内部被改变，并可返回，调用输入设置的无效
7. INOUT,调用时指定，并且可被改变和返回
8. **调用用call声明，call 存储过程名字 （参数）**
9. **设置变量set,用户变量名一般以@开头**
10. 查询

```mysql
# 调用
mysql > SET @p_in=1;  
mysql > CALL demo_in_parameter(@p_in);
# 查询库中的存储过程名字
mysql > select name from mysql.proc where db=’数据库名’;
# 查询存储过程详情
mysql > show create procedure 数据库名.存储过程名
```

# 五、自定义函数
1. mysql内置的常用函数，mysql也支持自定义函数，完成常用sql语句的封装

## 存储过程与函数的异同

#### 相同点
- 存储过程和函数都是为了可重复的执行操作数据库的 sql 语句的集合.
- 存储过程和函数都是首次编译,就会被缓存起来,下次使用就直接命中缓存中已经编译好的 sql, 不需要重复编译
- 减少网络交互,减少网络访问流量

#### 不同点
- 标识符不同,函数的标识符是 function, 过程:procedure
- 函数中有返回值,且必须有返回值,存储过程没有返回值,但是可以通过设置参数类型(in,out)来实现多个参数或者返回值
- 函数使用select调用，存储过程需要使用 call调用
- select 语句可以在存储过中调用,函数只能调用select ... into 语句
- 通过 in out 参数,过程相关函数更加灵活,可以返回多个结果
- 在实际开发中根据个人喜好选择使用函数或者存储过程

# 六、视图
1. 对复杂查询的封装，定义视图，建议以v_开头

```mysql
# 创建视图v_stu_score，查询学生对应的成绩信息
create view v_stu_score as
select students.*,scores.score from scores
inner join students on scores.stuid=students.id;
```

2. show tables; 查看表，会将视图也列出来
3. select * from v_stu_score; 使用视图

# 七、事务

## 1 概念
1. **事务**(Transaction)**是并发控制的基本单位**。它是一个**操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位**
2. 事务是数据库维护数据一致性的单位，
在每个事务结束时，都能保持数据一致性

## 2 四大特性
1. 原子性，事务操作要么全部执行，要不均不执行
2. 一致性，事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态
3. 隔离性，事务执行不受其他事务的干扰
4. 持久性，已提交的事务，其对数据库的改变不被丢弃

## 3 事务命令
1. 表的引擎必须是innodb
2. 修改数据的命令会触发事务，包括insert、update、delete
- **开启事务，begin;** 开启事务后执行修改命令，变更会维护到本地缓存中，不维护到物理表中
- **提交事务，commit;**
将缓存中的数据变更维护到物理表中
- **回滚事务，rollback;**
放弃缓存中变更的数据

# 八、悲观锁、乐观锁

## 1 悲观锁：
1. 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以**每次在拿数据时先上锁，数据处理完，再释放锁，别人想拿这个数据就会阻塞直到其拿到锁。**
2. 即**共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程。**
3. 传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
4. **悲观锁适用于多写的场景下**

## 2 乐观锁
1. 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以**不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现**
2. **乐观锁适用于多读的应用类型，这样可以提高吞吐量**

#### 2.1 version 版本号实现乐观锁
1. 一般是**在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一**。当线程A要更新数据值时，在读取数据的同时也会读取version值，**在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新**，否则重试更新操作，直到更新成功。

#### 2.2 CAS算法实现乐观锁
1. 即compare and swap（比较与交换），是一种有名的**无锁算法**。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步。CAS算法涉及到三个操作数
- 需要读写的内存值 V
- 进行比较的值 A
- 拟写入的新值 B
2. **当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。**
3. 经典的 **'ABA'问题**不适用于CAS算法乐观锁

# 九、隔离级别

## 1. 介绍
1. **隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性**。
1. Mysql的事务隔离级别一共有四个:**读未提交、读已提交、可重复读、可串行化**。
2. **Mysql的默认级别可重复读**。
2. 例子前提数据：数据库中存在id=1，name='武汉市'的数据。

## 2. 并发可能出现的情况

### 1. 脏读(Dirty Read)
1. **一个事务读到了另一个未提交事务修改过的数据**
2. 脏读只在读未提交隔离级别才会出现。
> 会话B开启一个事务，把id=1的name为武汉市修改成温州市，此时另外一个会话A也开启一个事务，读取id=1的name，此时的查询结果为温州市，会话B的事务最后回滚了刚才修改的记录，这样会话A读到的数据是不存在的，这个现象就是脏读。（脏读只在读未提交隔离级别才会出现）

### 2. 不可重复读(Non-Repeatable Read)
1. **一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询到最新值。**
2. 不可重复读在读未提交和读已提交隔离级别才可能会出现。
> 会话A开启一个事务，查询id=1的结果，此时查询的结果name为武汉市。接着会话B把id=1的name修改为温州市（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），此时会话A的事务再一次查询id=1的结果，读取的结果name为温州市。会话B再此修改id=1的name为杭州市，会话A的事务再次查询id=1，结果name的值为杭州市，这种现象就是不可重复读。

### 3. 幻读(Phantom)
1. **一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次查询时，能把另一个事务插入的记录也读出来**
2. 幻读在读未提交、读已提交、可重复读隔离级别都可能会出现
> 会话A开启一个事务，查询id>0的记录，此时会查到name=武汉市的记录。接着会话B插入一条name=温州市的数据（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），这时会话A的事务再以刚才的查询条件（id>0）再一次查询，此时会出现两条记录（name为武汉市和温州市的记录），这种现象就是幻读。

## 3. 隔离级别
1. Mysql的隔离级别共四个：读未提交、读已提交、可重复读、可串行化。
2. **隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性**。
3. **隔离级别比较：可串行化 > 可重复读 > 读已提交 > 读未提交**
4. **隔离级别对性能的影响比较：可串行化 > 可重复读 > 读已提交 > 读未提交**
5. **隔离级别越高，所需要消耗的Mysql性能越大(如事务并发严重性)**，为了平衡二者，一般设置的隔离级别为Mysql的默认级别**可重复读**。

### 1. 读未提交(READ UNCOMMITTED)
1. **在读未提交级别下，事务A可以读取到事务B修改过但未提交的数据**。
2. 可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别

### 2. 读已提交(READ COMMITTED)
1. **在读已提交级别下，事务B只能在事务A修改并已提交后才能读取到事务A的数据**。
2. 读已提交解决了脏读问题，但可能发生不可重复读和幻读问题，一般很少使用。

### 3. 可重复读(REPEATABLE READ)
1. **在可重复读级别下，在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的**
2. 可重复读解决了脏读和不可重复读的问题，但可能发生幻读。
3. 提问:为什么上了写锁(写操作)，别的事务还可以读操作，因为InnoDB有MVCC机制(多版本并发控制)，可以使用快照读，而不会被阻塞。

### 4. 可串行化(SERIALIZABLE)
1. **可串行化级别下，读读操作不会阻塞，其他的均会阻塞**
- 读读操作不会阻塞，两个事物都进行读操作不会阻塞
- 读写操作会阻塞
- 写读操作会阻塞
- 写写操作会阻塞
2. 各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）

## 4. 四种隔离级别的比较
隔离级别 | 脏读 | 不可重复读 | 幻读
---|---|---|---|
读未提交 | 可能 | 可能 | 可能
读已提交 | 不会 | 可能 | 可能
可重复读 | 不会 | 不会 | 可能
可串行化 | 不会 | 不会 | 不会

## 5. 隔离级别的实现原理

### 1. 原理
1. 每条记录在更新的时候都会同时记录一条回滚操作(回滚操作日志undo log)，同一条记录在系统中可以存在多个版本，这就是数据库的**多版本并发控制(MVCC)**，即通过回滚操作，可以回到前一个状态的值。
2. Q：回滚操作日志什么时候删除?
   R：Mysql会判断当没有事务需要用到这些回滚日志的时候，回滚日志就会被删除。
3. Q：什么时候不需要了？R：当系统里么有比这个回滚日志更早的read-view的时候。

### 2. 查看当前会话的隔离级别
1. 方式一：SHOW VARIABLES LIKE 'transaction_isolation';
2. 方式二：SELECT @@transaction_isolation;

### 3. 设置隔离级别

#### 3.1 通过set命令
1.

```mysql
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;
其中level有4种值：
level: {
     READ UNCOMMITTED  # 读未提交
   | READ COMMITTED   # 读已提交
   | REPEATABLE READ  # 可重复度
   | SERIALIZABLE  # 可串行化
}
```

2. 关键词：GLOBAL

```mysql
SET GLOBAL TRANSACTION ISOLATION LEVEL level;
* 只对执行完该语句之后产生的会话起作用
* 当前已经存在的会话无效
```
3. 关键词：SESSION

```mysql
SET SESSION TRANSACTION ISOLATION LEVEL level;
* 对当前会话的所有后续的事务有效
* 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务
* 如果在事务之间执行，则对后续的事务有效。
```
4. 无关键词

```mysql
SET TRANSACTION ISOLATION LEVEL level;
* 只对当前会话中下一个即将开启的事务有效
* 下一个事务执行完后，后续事务将恢复到之前的隔离级别
* 该语句不能在已经开启的事务中间执行，会报错的
```

#### 3.2 通过服务启动项命令
> 可以修改启动参数transaction-isolation的值

比方说我们在启动服务器时指定了--transaction-isolation=READ UNCOMMITTED，那么事务的默认隔离级别就从原来的REPEATABLE READ变成了READ UNCOMMITTED。

# 十、主从复制

## 1. 主从复制原理
1. **MySQL数据库自身提供的主从复制**功能可以方便的实现数据的多处自动备份，实现数据库的拓展.
2. 通过实现读写分离还能进一步提升数据库的负载性能.
![image](https://note.youdao.com/yws/res/27490/3A67EAEE2B934983AAA00F9DF91DA646)
4. 在一主多从的数据库体系中，多个**从服务器采用异步的方式更新主数据库的变化**，业务服务器在执行写或者相关修改数据库的操作是在主服务器上进行的，读操作则是在各从服务器上进行。

## 2. 主从复制的流程
1. 主库db的更新事件(update、insert、delete)被写到binlog
2. 主库创建一个binlog dump thread，把binlog的内容发送到从库
3. 从库启动并发起连接，连接到主库
4. 从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log
5. 从库启动之后，创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db
![image](https://note.youdao.com/yws/res/27487/72CABE6F0BD4411C89D5BA207DCE5BE1)
6. MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点

## 3. 主从配置
**配置主数据库**
1. 主库my.conf配置添加：

```shell
server-id=1   #主数据库的id
log-bin=master-bin   #日志路径，作用是从数据库是根据这个日志来复制主数据库的数据的
```
2. 停止mariadb服务：systemctl stop mariadb.service
3. mariadb授权远程用户(slaveuser为用户名和密码)

```mysql
1. grant replication slave on *.* to 'slaveuser'@'127.0.0.1' identified by 'slaveuser';
2. flush privileges;
```
4. 重启mariadb服务:

```shell
systemctl restart mariadb.service
```
**配置从数据库**
1. 修改从库的my.conf配置

```shell
server-id=2   #这个id必须不能和主数据库相同
read-only=on  #设置该数据库是只读状态
relay-log=relay-bin  #日志
```
2. 重启mariadb服务
3. 进入从服务器的数据库：master_host为主服务器

```mysql
change master to master_host='127.0.0.1',master_user='slaveuser',master_password='slaveuser', master_log_file='master-bin.000005',master_log_pos=882;
```
4. 启动slave同步

```mys;
START SLAVE;
```
5. 在从库上查看salave状态：

```mysql
show slave status\G
```
6. 看**Slave_IO_Running和Slave_SQL_Running**是都为yes


## 2. Django项目配置读写分离
1. 首先django配置文件settings配置slave从库信息

```shell
DATABASES = {
	'default': {
    	'ENGINE': 'django.db.backends.mysql',
    	'HOST': '127.0.0.1',
    	'PORT': 3306,  # 主
    	'USER': 'root',   # 主数据库用户名
    	'PASSWORD': 'password', # 主数据库密码
    	'NAME': 'database'  # 主数据库名字
		},
	'slave': {
    	'ENGINE': 'django.db.backends.mysql',
    	'HOST': '127.0.0.1',
    	'PORT': 3307,  #从
		'USER': 'root',   # 从数据库用户名
  		'PASSWORD': 'password', # 从数据库密码
  		'NAME': 'database'  # 从数据库名字
  		}
  	}
```

2. 创建路由分发类db_router.py，并在该文件中定义一个db类,用来进行读写分离。

```python
class MysqlDBRouter(object):
	"""数据库主从读写分离路由"""

	def db_read(self, model, **hints):
    	"""读数据库"""
    	return "slave"  # 一从时
    	import random  # 多从时，随机返回
        return random.choice(['slave', 'slave2', 'slave3'])

	def db_write(self, model, **hints):
    	"""写数据库"""
    	return "default"

	def allow_relation(self, obj1, obj2, **hints):
    	"""是否运行关联操作"""
    	return True
```
3. 项目setting配置文件中配置读写分离路由

```python
# 配置读写分离
DATABASE_ROUTERS = ['itme_name.utils.db_router.MysqlDBRouter']  # 指定你的路由分发类
```

# 十一、Galera主主高可用
1. 基于Galera的MySQL高可用集群， 是多主数据同步的MySQL集群解决方案，使用简单，没有单点故障，可用性高。架构如下：
![image](https://note.youdao.com/yws/res/27488/EFED1E31AB344B45AE76BB09AFBD54BD)
2. 图1所示为一个三节点Galera 集群，三个MySQL实例是对等的，互为主从，这被称为多主（multi-master）架构。当客户端读写数据时，可连接任一MySQL实例。对于读操作，从每个节点读取到的数据都是相同的。对于写操作，当数据写入某一节点后，集群会将其同步到其它节点。这种架构不共享任何数据，是一种**高冗余架构**。
3. *优点*
- 多主写入，无延迟复制，能保证数据强一致性；
- 有成熟的社区，有互联网公司在大规模的使用；
- 自动故障转移，自动添加、剔除节点；
4. *缺点*
- 需要为原生MySQL节点打wsrep补丁
- 只支持innodb储存引擎
- 至少三节点；
5. Galera集群复制要求数据库系统支持事务，因此**仅支持MySQL的Innodb存储引擎**，并且多主模式下只能使用**可重复读隔离级别**。

# 十二、触发器(trigger)

## 1. 概述
1. 当满足一定条件时，执行触发器中的一些操作。
2. **由事件来触发某个操作，事件包括INSERT、UPDATE和DELETE语句；可以协助应用在数据库端确保数据的完整性。**
3. 触发器的特性：
- **有begin end体**，begin end;之间的语句可以写的简单或者复杂
- 什么**条件会触发：表数据的增删改**
- 什么时候触发：在增删改前或者后
- **触发频率：针对每一行执行**
- **触发器定义在表上，附着在表上。**
4. 触发器尽量少的使用，因为不管如何，它还是很消耗资源，如果使用的话要谨慎的使用，确定它是非常高效的：**触发器是针对每一行的；对增删改非常频繁的表上切记不要使用触发器，因为它会非常消耗资源。**

## 2. 使用
1. 创建触发器

```mysql
CREATE
    [DEFINER = { user | CURRENT_USER }]
TRIGGER trigger_name
trigger_time trigger_event
ON tbl_name FOR EACH ROW
　　[trigger_order]
trigger_body

trigger_time: { BEFORE | AFTER }

trigger_event: { INSERT | UPDATE | DELETE }

trigger_order: { FOLLOWS | PRECEDES } other_trigger_name
```
2. BEFORE和AFTER参数指定了触发执行的时间，在事件之前或是之后
3. FOR EACH ROW表示任何一条记录上的操作满足触发事件都会触发该触发器，也就是说触发器的触发频率是针对每一行数据触发一次。
4. trigger_order是MySQL5.7之后的一个功能，用于定义多个触发器，使用follows(尾随)或precedes(在…之先)来选择触发器执行的先后顺序。 
5. **创建有多个执行语句的触发器**

```mysql
CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件

ON 表名 FOR EACH ROW

BEGIN

        执行语句列表

END;
```
6. 查看触发器：mysql> **SHOW TRIGGERS**\G;
7. **删除触发器：DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name**
8. 如果不需要某个触发器时一定要将这个触发器删除，以免造成意外操作，这很关键。
